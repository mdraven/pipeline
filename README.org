
* О библиотеке

  Я написал эту библиотеку для того чтобы убедиться, что
  unified call syntax не так уж и нужен.

  Эта библиотека не позволяет передавать через pipeline
  несколько значений, выбирать какой аргумент получит
  эти значение. Но зато библиотека довольно простая и
  относительно быстро компилируется.

  Передаче нескольких значений и выбор аргумента-получателя
  можно сделать не трогая исходный код данной библиотеки.
  - Несколько значений можно сделать с помощью обёртки
    генерирующий код похожий на данный:
    #+BEGIN_SRC cpp
      template <class T1, class T2>
      auto get_pair(const std::pair<T1, T2>& pair) {
          return my_func(pair.first, pair.second);
      }
    #+END_SRC
  - Выбор аргумента делается по тому же принциму что и
    получение нескольких значений.

  Если говорить об итогах, то ucs всё же нужен по такой
  причине:
  #+BEGIN_SRC cpp
    print(Data().inc(1).inc(1));                            // 1

    Data() | inc_(1) | inc_(1) | print_;                    // 2

    Data() | &Data::inc A(1) | &Data::inc A(1) | print A(); // 3
  #+END_SRC
  Тут написаны 3 способа вызова метода класса. UCS позволяет
  вызывать и функции и методы как методы, а это упрощает
  чтение. Те вместо =func1(func2(func3(data)))= мы можем
  написать =data.func3().func2().func1()=.
  Так вот: 1-ый способ -- это вызов методов Data();
  2-ой способ возможен если мы поместим Data::inc в inc_, а
  это требует дополнительных телодвижений;
  3-й способ не требует писать дополнительный код, но он выглядит
  ужасно.

  Но у pipe'ов есть (+) с помощью них можно делать не просто
  вызов, а вызов содержащий логику. Например что-то вроде Maybe.
* Вызов функции из PipeOpFactory

  У меня была мысль добавить возможность вызова функции находящейся
  в PipeOpFactory. Сейчас приходится писать =print(sum(2)(1));=
  вместо =print(sum(1, 2));=. Но добавить такую возможность не
  получилось так как я не знаю как поступить в данном случае:
  #+BEGIN_SRC cpp
    struct Sum {
        int operator()(int i, int j);        // 1
        int operator()(int i, int j, int k); // 2
    };

    auto sum = pipe_op_factory(Sum());

    print(sum(1, 2)); // это вызов метода 1, или привязка метода 2?
  #+END_SRC

* Про JUST_RETURN

  Загрязнив код с помощью JUST_RETURN я добился некоторой оптимизации.
  Дело в том, что auto и decltype по разному выводят тип и decltype
  делает это более точно(но менее умно). Поэтому если какой-нибудь
  метод(или функция), из тех которые мы обрабатываем для работы в
  pipeline, возвращает ссылку на что-то, например: =setData(int i) -> Data&=,
  то auto превратит =Data&= в =Data= и сделает копию, а decltype вернёт
  ссылку.

  Поэтому приходится терпеть JUST_RETURN. Просто нужно его писать
  не везде, а там где мы работаем с полученным извне методом(функцией).

  Вот например тут JUST_RETURN не нужен:
  #+BEGIN_SRC cpp
    template <class Ret, class Klass, class... Args>
    auto function(Ret(Klass::*t)(Args...) const) {
        return Callable<CallableMethod, const Klass, Ret, Args...>(t);
    }
  #+END_SRC
  Callable и так возвращает rvalue.
* Про другой подход

  В данном случае в специальный тип заворачивается правая часть
  оператора |, но можно заворачивать левую:
  #+BEGIN_SRC cpp
  pipe(5) | times << args([] { do_some(); });
  #+END_SRC

  У такого способа есть большой '+': нет необходимости заворачивать
  функции в новый тип, а функций больше чем передаваемых значений,
  и это значит, что такой способ удобнее.

  В данном способе менее удобно передавать аргументы и придётся
  или заворачивать аргументы в тип, или заворачивать саму функцию
  в тип(но тогда мы вернёмся к первому способу).

  Как видно в примере выше для функции принимающей больше одного
  параметра выгоды нет. Там написано также как и для первого
  способа. Выгода есть для функции пинимающей один аргумент:
  #+BEGIN_SRC cpp
  pipe(vector(1,2,3)) | size;
  #+END_SRC
  Против:
  #+BEGIN_SRC cpp
  pipe(vector(1,2,3)) | size A();
  #+END_SRC
